syntax = "proto3";
package sigstore;

// https://raw.githubusercontent.com/secure-systems-lab/dsse/9c813476bd36de70a5738c72e784f123ecea16af/envelope.proto
import "envelope.proto";

option go_package = "github.com/sigstore/xxx/bundle";
option java_package = "com.github.sigstore.xxx.bundle";

// Notes on versioning.
// The primary message ('Bundle') MUST be versioned, by populating the
// 'media_type' field. Semver-ish (only major/minor versions) scheme MUST
// be used. The current version as specified by this file is:
// application/vnd.dev.sigstore.bundle+json;version=0.1
// The semantic version is thus '0.1'.

// Only a subset of the secure hash standard algorithms are supported.
// See https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf for more
// details.
enum HashAlgorithm {
        SHA2_256 = 0;
        SHA2_512 = 1;
}

// HashOutput captures a digest of a 'message' and the corresponding hash
// algorithm used.
message HashOutput {
        HashAlgorithm algorithm = 1;
        // This is the raw octets of the message digest as computed by
        // the hash algorithm.
        bytes digest = 2;
}

// MessageSignature stores the computed signature over a message
// (generic octet sequence).
message MessageSignature {
        // Message digest can be used to identify the artifact.
        HashOutput message_digest = 1;
        // The raw bytes as returned from the signature algorithm.
        // The signature algorithm (and so the format of the signature bytes)
        // are determined by the contents of the 'verification_material',
        // either a key-pair or a certificate. If using a certificate, the
        // certificate contains the required information on the signature
        // algorithm.
        // When using a key pair, the algorithm MUST be part of the public
        // key, which MUST be communicated out-of-band.
        bytes signature = 2;
}

// RekorKindVersion contains the entry's kind and api version.
message RekorKindVersion {
        // Kind is the type of entry being stored in the log.
        // See here for a list: https://github.com/sigstore/rekor/tree/main/pkg/types
        string kind = 3;
        // The specific api version of the type.
        string version = 4;
}

// InclusionProof is the proof returned from the transparency log. Can
// be used for on line verification against the log.
message InclusionProof {
        // The index of the entry in the log.
        int64 log_index = 1;
        // The hash value stored at the root of the merkle tree at the time
        // the proof was generated, hex encoded.
        string root_hash = 2;
        // The size of the merkle tree at the time the proof was generated.
        int64 tree_size = 3;
        // A list of hashes required to compute the inclusion proof, sorted
        // in order from leaf to root. Each hash value is hex encoded.
        repeated string hashes = 4;
        // The checkpoint contains a signature of the tree head (root hash),
        // size of the tree, the transparency log's unique identifier
        // (log ID), hostname and the current time.
        // The result is a string, the format is described here
        // https://github.com/transparency-dev/formats/blob/main/log/README.md
        // The details are here https://github.com/sigstore/rekor/blob/main/pkg/util/signed_note.go#L114.
        // The signature has the same format as
        // TransparencyLogEntry.inclusion_proof. See below for more details.
        string checkpoint = 5;
}

// TransparencyLogEntry is a separate type, capturing all the details required
// from Rekor to reconstruct an entry, given that the payload is provided
// via other means.
// This type can easily be created from the existing response from Rekor.
// Future iterations could rely on Rekor returning the minimal set of
// attributes (excluding the payload) that are required for verifying the
// inclusion promise. The inclusion promise (called SignedEntryTimestamp
// the response from Rekor) is similar to a Signed Certificate Timestamp
// as described here https://www.rfc-editor.org/rfc/rfc9162#name-signed-certificate-timestam.
message TransparencyLogEntry {
        // The index of the entry in the log.
        int64 log_index = 1;
        // The unique (binary) identifier of the log, as a hex-encoded string.
        string log_id = 2;
        // The kind (type) and version of the object associated with this
        // entry. These values are required to construct the entry during
        // verification.
        RekorKindVersion kind_version = 3;
        // The UNIX timestamp from the log when the entry was persisted.
        int64 integrated_time = 4;
        // The inclusion promise is calculated by Rekor. It's calculated as a
        // signature over a canonical JSON serialization of the persisted
        // entry, the log ID, log index and the integration timestamp.
        // See https://github.com/sigstore/rekor/blob/main/pkg/api/entries.go#L54
        // The signature is base64 encoded.
        // The format of the signature depends on the transparency log's
        // public key. If the signature algorithm requires a hash function
        // and/or a signature scheme (e.g. RSA) those has to be retrieved
        // out-of-band from the log's operators, together with the public
        // key.
        // This is primarily used to verify the
        // integration timestamp's value.
        string inclusion_promise = 5;
        // The inclusion proof can be used for online verification that the
        // entry was appended to the log, and that the log has not been
        // altered.
        optional InclusionProof inclusion_proof = 6;
}

// This message holds a RFC 3161 timestamp.
message RFC3161SignedTimestamp {
        // Signed timestamp is the DER encoded TSTInfo.
        // See https://www.rfc-editor.org/rfc/rfc3161.html#section-2.4.2
        // Clients MUST verify the hashed message in the message imprint
        // against the artifact. Note that the message hash algorithm may
        // differ from the one in message signature, or the subject of the
        // DSSE envelope.
        string signed_timestamp = 1;
}

// This message holds different constructs that captures the timestamp
// of the time the signature was generated.
// As this message can be either empty (no timestamps), or a combination of
// an arbitrarily number of transparency log entries and signed timestamps,
// it is the client's responsibility implement any required verification
// policies.
message TimestampVerificationData {
        // This is the regular inclusion promise and proof, where
        // the timestamp is coming from the transparency log.
        repeated TransparencyLogEntry tlog_entries = 1;
        // A list of RFC3161 signed timestamps provided by the user.
        // This can be used when the entry has not been stored on a
        // transparency log.
        repeated RFC3161SignedTimestamp rfc3161_timestamps = 2;
}

// PublicKeyIdentifier can be used to identify an (out of band) delivered
// key, to verify a signature.
message PublicKeyIdentifier {
        // Optional unauthenticated hint on which key to use.
        // The format of the hint must be agreed upon out of band by the
        // signer and the verifiers, and so is not subject to this
        // specification.
        string hint = 1;
}

message X509CertificateChain {
        // PEM encoded certificate(s), with indices 0 to n.
        // For information on PEM encoding, see
        // https://www.rfc-editor.org/rfc/rfc7468#section-2.
        // The first certificate in the array
        // must be the leaf certificate used for signing. Any intermediate
        // certificates must be stored as offset 1 to n-1, and the root
        // certificate at position n.
        repeated string certificates = 1;
}

message Bundle {
        // MUST be application/vnd.dev.sigstore.bundle+json;version=0.1
        // when encoded as JSON.
        string media_type = 1;
        TimestampVerificationData timestamp_verification_data = 2;
        oneof verification_material {
                PublicKeyIdentifier public_key = 3;
                X509CertificateChain x509_certificate_chain = 4;
        }
        oneof content {
                MessageSignature message_signature = 5;
                // A DSSE envelope can contain arbitrary payloads.
                // Verifiers must verify that the payload type a supported or
                // expected type. This is part of the DSSE protocol which
                // is defined here https://github.com/secure-systems-lab/dsse/blob/master/protocol.md
                io.intoto.Envelope dsse_envelope = 6;
        }
}
